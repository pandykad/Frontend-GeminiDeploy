import {
  __commonJS,
  __toESM
} from "./chunk-DC5AMYBS.js";

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@google/generative-ai/dist/server/index.mjs
var import_fs = __toESM(require_fs(), 1);
var GoogleGenerativeAIError = class extends Error {
  constructor(message) {
    super(`[GoogleGenerativeAI Error]: ${message}`);
  }
};
var GoogleGenerativeAIFetchError = class extends GoogleGenerativeAIError {
  constructor(message, status, statusText, errorDetails) {
    super(message);
    this.status = status;
    this.statusText = statusText;
    this.errorDetails = errorDetails;
  }
};
var GoogleGenerativeAIRequestInputError = class extends GoogleGenerativeAIError {
};
var DEFAULT_BASE_URL = "https://generativelanguage.googleapis.com";
var DEFAULT_API_VERSION = "v1beta";
var PACKAGE_VERSION = "0.16.0";
var PACKAGE_LOG_HEADER = "genai-js";
var Task;
(function(Task2) {
  Task2["GENERATE_CONTENT"] = "generateContent";
  Task2["STREAM_GENERATE_CONTENT"] = "streamGenerateContent";
  Task2["COUNT_TOKENS"] = "countTokens";
  Task2["EMBED_CONTENT"] = "embedContent";
  Task2["BATCH_EMBED_CONTENTS"] = "batchEmbedContents";
})(Task || (Task = {}));
function getClientHeaders(requestOptions) {
  const clientHeaders = [];
  if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.apiClient) {
    clientHeaders.push(requestOptions.apiClient);
  }
  clientHeaders.push(`${PACKAGE_LOG_HEADER}/${PACKAGE_VERSION}`);
  return clientHeaders.join(" ");
}
async function makeRequest(url, fetchOptions, fetchFn = fetch) {
  let response;
  try {
    response = await fetchFn(url, fetchOptions);
  } catch (e) {
    handleResponseError(e, url);
  }
  if (!response.ok) {
    await handleResponseNotOk(response, url);
  }
  return response;
}
function handleResponseError(e, url) {
  let err = e;
  if (!(e instanceof GoogleGenerativeAIFetchError || e instanceof GoogleGenerativeAIRequestInputError)) {
    err = new GoogleGenerativeAIError(`Error fetching from ${url.toString()}: ${e.message}`);
    err.stack = e.stack;
  }
  throw err;
}
async function handleResponseNotOk(response, url) {
  let message = "";
  let errorDetails;
  try {
    const json = await response.json();
    message = json.error.message;
    if (json.error.details) {
      message += ` ${JSON.stringify(json.error.details)}`;
      errorDetails = json.error.details;
    }
  } catch (e) {
  }
  throw new GoogleGenerativeAIFetchError(`Error fetching from ${url.toString()}: [${response.status} ${response.statusText}] ${message}`, response.status, response.statusText, errorDetails);
}
var RpcTask;
(function(RpcTask2) {
  RpcTask2["UPLOAD"] = "upload";
  RpcTask2["LIST"] = "list";
  RpcTask2["GET"] = "get";
  RpcTask2["DELETE"] = "delete";
  RpcTask2["UPDATE"] = "update";
  RpcTask2["CREATE"] = "create";
})(RpcTask || (RpcTask = {}));
var taskToMethod = {
  [RpcTask.UPLOAD]: "POST",
  [RpcTask.LIST]: "GET",
  [RpcTask.GET]: "GET",
  [RpcTask.DELETE]: "DELETE",
  [RpcTask.UPDATE]: "PATCH",
  [RpcTask.CREATE]: "POST"
};
var ServerRequestUrl = class {
  constructor(task, apiKey, requestOptions) {
    this.task = task;
    this.apiKey = apiKey;
    this.requestOptions = requestOptions;
  }
  appendPath(path) {
    this._url.pathname = this._url.pathname + `/${path}`;
  }
  appendParam(key, value) {
    this._url.searchParams.append(key, value);
  }
  toString() {
    return this._url.toString();
  }
};
var CachedContentUrl = class extends ServerRequestUrl {
  constructor(task, apiKey, requestOptions) {
    var _a, _b;
    super(task, apiKey, requestOptions);
    this.task = task;
    this.apiKey = apiKey;
    this.requestOptions = requestOptions;
    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
    let initialUrl = baseUrl;
    initialUrl += `/${apiVersion}/cachedContents`;
    this._url = new URL(initialUrl);
  }
};
var FilesRequestUrl = class extends ServerRequestUrl {
  constructor(task, apiKey, requestOptions) {
    var _a, _b;
    super(task, apiKey, requestOptions);
    this.task = task;
    this.apiKey = apiKey;
    this.requestOptions = requestOptions;
    const apiVersion = ((_a = this.requestOptions) === null || _a === void 0 ? void 0 : _a.apiVersion) || DEFAULT_API_VERSION;
    const baseUrl = ((_b = this.requestOptions) === null || _b === void 0 ? void 0 : _b.baseUrl) || DEFAULT_BASE_URL;
    let initialUrl = baseUrl;
    if (this.task === RpcTask.UPLOAD) {
      initialUrl += `/upload`;
    }
    initialUrl += `/${apiVersion}/files`;
    this._url = new URL(initialUrl);
  }
};
function getHeaders(url) {
  const headers = new Headers();
  headers.append("x-goog-api-client", getClientHeaders(url.requestOptions));
  headers.append("x-goog-api-key", url.apiKey);
  return headers;
}
async function makeServerRequest(url, headers, body, fetchFn = fetch) {
  const requestInit = {
    method: taskToMethod[url.task],
    headers
  };
  if (body) {
    requestInit.body = body;
  }
  const signal = getSignal(url.requestOptions);
  if (signal) {
    requestInit.signal = signal;
  }
  return makeRequest(url.toString(), requestInit, fetchFn);
}
function getSignal(requestOptions) {
  if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.signal) !== void 0 || (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
    const controller = new AbortController();
    if ((requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeout) >= 0) {
      setTimeout(() => controller.abort(), requestOptions.timeout);
    }
    if (requestOptions.signal) {
      requestOptions.signal.addEventListener("abort", () => {
        controller.abort();
      });
    }
    return controller.signal;
  }
}
var GoogleAIFileManager = class {
  constructor(apiKey, _requestOptions = {}) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
  }
  /**
   * Upload a file.
   */
  async uploadFile(filePath, fileMetadata) {
    const file = (0, import_fs.readFileSync)(filePath);
    const url = new FilesRequestUrl(RpcTask.UPLOAD, this.apiKey, this._requestOptions);
    const uploadHeaders = getHeaders(url);
    const boundary = generateBoundary();
    uploadHeaders.append("X-Goog-Upload-Protocol", "multipart");
    uploadHeaders.append("Content-Type", `multipart/related; boundary=${boundary}`);
    const uploadMetadata = getUploadMetadata(fileMetadata);
    const metadataString = JSON.stringify({ file: uploadMetadata });
    const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + fileMetadata.mimeType + "\r\n\r\n";
    const postBlobPart = "\r\n--" + boundary + "--";
    const blob = new Blob([preBlobPart, file, postBlobPart]);
    const response = await makeServerRequest(url, uploadHeaders, blob);
    return response.json();
  }
  /**
   * List all uploaded files.
   *
   * Any fields set in the optional {@link SingleRequestOptions} parameter will take
   * precedence over the {@link RequestOptions} values provided at the time of the
   * {@link GoogleAIFileManager} initialization.
   */
  async listFiles(listParams, requestOptions = {}) {
    const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const url = new FilesRequestUrl(RpcTask.LIST, this.apiKey, filesRequestOptions);
    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {
      url.appendParam("pageSize", listParams.pageSize.toString());
    }
    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {
      url.appendParam("pageToken", listParams.pageToken);
    }
    const uploadHeaders = getHeaders(url);
    const response = await makeServerRequest(url, uploadHeaders);
    return response.json();
  }
  /**
   * Get metadata for file with given ID.
   *
   * Any fields set in the optional {@link SingleRequestOptions} parameter will take
   * precedence over the {@link RequestOptions} values provided at the time of the
   * {@link GoogleAIFileManager} initialization.
   */
  async getFile(fileId, requestOptions = {}) {
    const filesRequestOptions = Object.assign(Object.assign({}, this._requestOptions), requestOptions);
    const url = new FilesRequestUrl(RpcTask.GET, this.apiKey, filesRequestOptions);
    url.appendPath(parseFileId(fileId));
    const uploadHeaders = getHeaders(url);
    const response = await makeServerRequest(url, uploadHeaders);
    return response.json();
  }
  /**
   * Delete file with given ID.
   */
  async deleteFile(fileId) {
    const url = new FilesRequestUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);
    url.appendPath(parseFileId(fileId));
    const uploadHeaders = getHeaders(url);
    await makeServerRequest(url, uploadHeaders);
  }
};
function parseFileId(fileId) {
  if (fileId.startsWith("files/")) {
    return fileId.split("files/")[1];
  }
  if (!fileId) {
    throw new GoogleGenerativeAIError(`Invalid fileId ${fileId}. Must be in the format "files/filename" or "filename"`);
  }
  return fileId;
}
function generateBoundary() {
  let str = "";
  for (let i = 0; i < 2; i++) {
    str = str + Math.random().toString().slice(2);
  }
  return str;
}
function getUploadMetadata(inputMetadata) {
  if (!inputMetadata.mimeType) {
    throw new GoogleGenerativeAIRequestInputError("Must provide a mimeType.");
  }
  const uploadMetadata = {
    mimeType: inputMetadata.mimeType,
    displayName: inputMetadata.displayName
  };
  if (inputMetadata.name) {
    uploadMetadata.name = inputMetadata.name.includes("/") ? inputMetadata.name : `files/${inputMetadata.name}`;
  }
  return uploadMetadata;
}
function formatSystemInstruction(input) {
  if (input == null) {
    return void 0;
  } else if (typeof input === "string") {
    return { role: "system", parts: [{ text: input }] };
  } else if (input.text) {
    return { role: "system", parts: [input] };
  } else if (input.parts) {
    if (!input.role) {
      return { role: "system", parts: input.parts };
    } else {
      return input;
    }
  }
}
var GoogleAICacheManager = class {
  constructor(apiKey, _requestOptions) {
    this.apiKey = apiKey;
    this._requestOptions = _requestOptions;
  }
  /**
   * Upload a new content cache
   */
  async create(createOptions) {
    const newCachedContent = Object.assign({}, createOptions);
    if (createOptions.ttlSeconds) {
      if (createOptions.expireTime) {
        throw new GoogleGenerativeAIRequestInputError("You cannot specify both `ttlSeconds` and `expireTime` when creating a content cache. You must choose one.");
      }
      if (createOptions.systemInstruction) {
        newCachedContent.systemInstruction = formatSystemInstruction(createOptions.systemInstruction);
      }
      newCachedContent.ttl = createOptions.ttlSeconds.toString() + "s";
      delete newCachedContent.ttlSeconds;
    }
    if (!newCachedContent.model) {
      throw new GoogleGenerativeAIRequestInputError("Cached content must contain a `model` field.");
    }
    if (!newCachedContent.model.includes("/")) {
      newCachedContent.model = `models/${newCachedContent.model}`;
    }
    const url = new CachedContentUrl(RpcTask.CREATE, this.apiKey, this._requestOptions);
    const headers = getHeaders(url);
    const response = await makeServerRequest(url, headers, JSON.stringify(newCachedContent));
    return response.json();
  }
  /**
   * List all uploaded content caches
   */
  async list(listParams) {
    const url = new CachedContentUrl(RpcTask.LIST, this.apiKey, this._requestOptions);
    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageSize) {
      url.appendParam("pageSize", listParams.pageSize.toString());
    }
    if (listParams === null || listParams === void 0 ? void 0 : listParams.pageToken) {
      url.appendParam("pageToken", listParams.pageToken);
    }
    const headers = getHeaders(url);
    const response = await makeServerRequest(url, headers);
    return response.json();
  }
  /**
   * Get a content cache
   */
  async get(name) {
    const url = new CachedContentUrl(RpcTask.GET, this.apiKey, this._requestOptions);
    url.appendPath(parseCacheName(name));
    const headers = getHeaders(url);
    const response = await makeServerRequest(url, headers);
    return response.json();
  }
  /**
   * Update an existing content cache
   */
  async update(name, updateParams) {
    const url = new CachedContentUrl(RpcTask.UPDATE, this.apiKey, this._requestOptions);
    url.appendPath(parseCacheName(name));
    const headers = getHeaders(url);
    const formattedCachedContent = Object.assign({}, updateParams.cachedContent);
    if (updateParams.cachedContent.ttlSeconds) {
      formattedCachedContent.ttl = updateParams.cachedContent.ttlSeconds.toString() + "s";
      delete formattedCachedContent.ttlSeconds;
    }
    if (updateParams.updateMask) {
      url.appendParam("update_mask", updateParams.updateMask.map((prop) => camelToSnake(prop)).join(","));
    }
    const response = await makeServerRequest(url, headers, JSON.stringify(formattedCachedContent));
    return response.json();
  }
  /**
   * Delete content cache with given name
   */
  async delete(name) {
    const url = new CachedContentUrl(RpcTask.DELETE, this.apiKey, this._requestOptions);
    url.appendPath(parseCacheName(name));
    const headers = getHeaders(url);
    await makeServerRequest(url, headers);
  }
};
function parseCacheName(name) {
  if (name.startsWith("cachedContents/")) {
    return name.split("cachedContents/")[1];
  }
  if (!name) {
    throw new GoogleGenerativeAIError(`Invalid name ${name}. Must be in the format "cachedContents/name" or "name"`);
  }
  return name;
}
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
var FileState;
(function(FileState2) {
  FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
  FileState2["PROCESSING"] = "PROCESSING";
  FileState2["ACTIVE"] = "ACTIVE";
  FileState2["FAILED"] = "FAILED";
})(FileState || (FileState = {}));
var FunctionDeclarationSchemaType;
(function(FunctionDeclarationSchemaType2) {
  FunctionDeclarationSchemaType2["STRING"] = "STRING";
  FunctionDeclarationSchemaType2["NUMBER"] = "NUMBER";
  FunctionDeclarationSchemaType2["INTEGER"] = "INTEGER";
  FunctionDeclarationSchemaType2["BOOLEAN"] = "BOOLEAN";
  FunctionDeclarationSchemaType2["ARRAY"] = "ARRAY";
  FunctionDeclarationSchemaType2["OBJECT"] = "OBJECT";
})(FunctionDeclarationSchemaType || (FunctionDeclarationSchemaType = {}));
var ExecutableCodeLanguage;
(function(ExecutableCodeLanguage2) {
  ExecutableCodeLanguage2["LANGUAGE_UNSPECIFIED"] = "language_unspecified";
  ExecutableCodeLanguage2["PYTHON"] = "python";
})(ExecutableCodeLanguage || (ExecutableCodeLanguage = {}));
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "outcome_unspecified";
  Outcome2["OUTCOME_OK"] = "outcome_ok";
  Outcome2["OUTCOME_FAILED"] = "outcome_failed";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "outcome_deadline_exceeded";
})(Outcome || (Outcome = {}));
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var BlockReason;
(function(BlockReason2) {
  BlockReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockReason2["SAFETY"] = "SAFETY";
  BlockReason2["OTHER"] = "OTHER";
})(BlockReason || (BlockReason = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["OTHER"] = "OTHER";
})(FinishReason || (FinishReason = {}));
var TaskType;
(function(TaskType2) {
  TaskType2["TASK_TYPE_UNSPECIFIED"] = "TASK_TYPE_UNSPECIFIED";
  TaskType2["RETRIEVAL_QUERY"] = "RETRIEVAL_QUERY";
  TaskType2["RETRIEVAL_DOCUMENT"] = "RETRIEVAL_DOCUMENT";
  TaskType2["SEMANTIC_SIMILARITY"] = "SEMANTIC_SIMILARITY";
  TaskType2["CLASSIFICATION"] = "CLASSIFICATION";
  TaskType2["CLUSTERING"] = "CLUSTERING";
})(TaskType || (TaskType = {}));
var FunctionCallingMode;
(function(FunctionCallingMode2) {
  FunctionCallingMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingMode2["AUTO"] = "AUTO";
  FunctionCallingMode2["ANY"] = "ANY";
  FunctionCallingMode2["NONE"] = "NONE";
})(FunctionCallingMode || (FunctionCallingMode = {}));
export {
  ExecutableCodeLanguage,
  FileState,
  FunctionCallingMode,
  FunctionDeclarationSchemaType,
  GoogleAICacheManager,
  GoogleAIFileManager,
  Outcome
};
/*! Bundled license information:

@google/generative-ai/dist/server/index.mjs:
  (**
   * @license
   * Copyright 2024 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=@google_generative-ai_server.js.map
